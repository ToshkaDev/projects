# Introduction
Writing documentation is not a glamorous task. Nonetheless, well-written documentation is vital to producing good software both for end-users and developers.

To remove as much manual effort as possible, a significant portion of the MiST API documentation is automatically generated by introspecting the underlying source code. For example, the REST endpoints may be inferred because they are derived from the directory structure in the `src/routes` directory (e.g. `src/routes/genomes` corresponds to the `/genomes` URI). If each URI is written manually, it must now be maintained in two places (the file structure and the documentation). Such an approach is not *[DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)* and subject to errors. With scripting, it is possible to automatically scan the directory structure and generate accurate endpoints that directly reflect the source code single source of truth. Of course, there are sections that must be written manually and support for this is also accommodated.

The MiST API documentation leverages a modified [node-slate](https://github.com/sdelements/node-slate) framework to produce beautiful and user-friendly documentation. Compiling the docs (see below) produces a static website containing all the documentation  in the `src/docs/build` directory. The API itself has been coded to statically serve up this content when visiting either the api root `/` or `/v{version}/docs`.


# Building the documentation
Run the following commands inside the biowonks-dev container:

```bash
(docker) /app $ cd mist-api
(docker) /app/mist-api $ npm install
(docker) /app/mist-api $ npm run build-docs
```

The above `npm install` command first installs the mist-api node modules and afterwards installs the node packages needed to compile the documentation.

To view the generated documentation, first start the api:
```bash
(docker) /app/mist-api $ npm start
```

Open [localhost:5000](http://localhost:5000) in your web browser.

After making any changes to the documentation, re-run `npm run build-docs` and refresh the browser.


# Configuration
Please see the annotated configuration in `mist-api/src/docs/config.js`.


# Manual Content
Manual content consists of HTML or [pug](https://pugjs.org/api/getting-started.html) files which are glued together into a single final HTML file. These files are located in the `mist-api/src/docs/source/includes` directory and must be suffixed with either `.html` or `.pug`. These are not auto-generated.

## Modifying an *existing* section
1. Open the desired file (located within the `mist-api/src/docs/source/includes` directory)
2. Make the desired changes
3. Re-build the documentation (`npm run build`)

> Note: Automatically generated files are also stored within the `includes` directory. Editing this files manually will have no effect as these changes will be overwritten the next time the documentation is compiled.

## Creating a *new* section
1. Create a new HTML or pug file in `mist-api/src/docs/source/includes` with the appropriate extension
2. Add some content and save the file
3. Open `mist-api/src/docs/config.js`
4. Add the filename (do not include any of the path) of this new file to the `includes` array. Take note of the order within this array as it determines the order on the final documentatoin
5. Re-build the documentation (`npm run build`)


# Auto Generated Content
As discussed in the introducion, documentation for the routes may be partially automated to both save time and improve accuracy. Generating example model structures is another example. Currently, these are the only two parts automatically generated and are discussed in detail below.

## Routes
Just like having unit tests in close virtual proximity to the code they test (they are stored in a similarly named file in the same directory), it is preferred for the route documentation to be close proximity to the code that handles that route. Thus, to provide details about a particular endpoint, an optional function named docs may also be exported from the same file:

```javascript
// File: mist-api/src/routes/genomes/get.js
'use strict'

// GET /genomes
module.exports = function(app, middlewares, routeMiddlewares) {
    // Code for handling the route
}

module.exports.docs = function(modelExamples) {

}
```

When `npm run build` is executed, this process involves walking through all the defined routes (using [path-routify](https://github.com/lukeulrich/path-routify)) and executing the docs function if it is exported. The result returned from this function is minimally processed and then compiled using [pug](https://pugjs.org/api/getting-started.html) with the `mist-api/src/docs/source/templates/route.pug` template. The collective HTML for all routes is then saved to `mist-api/src/docs/source/includes/rest-api.html`, which gets incorporated into the final HTML file.

> Note: the `docs` function is passed a single argument, `modelExamples`, which is an object containing an example object for each model of the MiST-API. This is quite helpful in producing more useful documentation such as providing example responses.

### Expected structure of the docs return object
The `docs` function expects to receive an object like the following:

```javascript
{
    // Friendly short name for this endpoint; defaults to ${http method} ${uri} (e.g. GET /genomes)
    name: 'Fetch Many Genomes',
    // HTML or plain text description of what this function does
    description: 'Returns an array of genomes',
    // HTTP method; automatically inferred unless overridden here
    method: null,
    // Endpoint; automatically inferred unless overridden here
    uri: null,
    // Object.<String,Object> description of parameters qualifying this endpoint. Each key is the
    // parameter name and each value is a two element object. For example:
    // {
    //   id: {
    //     type: 'integer',
    //     description: 'A positive number uniquely identifying this record'
    //   }
    // }
    parameters: null,
    // Example response
    example: {
        // If the method is GET, then all aspects of request is automatically inferred
        request: {
            endpoint: null,
            baseUrl: null,
            parameters: {}
        },
        // An example result returned from calling this endpoint. In this case, the body is an
        // array of Genome model records. This shows how the modelExamples argument is useful for
        // producing example responses.
        response: {
            body: [
                modelExamples.Genome
            ]
        }
    },
    // HAR = HTTP Archive Spec format; this is used by the node HTTPSnippet package to produce
    // the relevant snippets. Automatically inferred for GET routes.
    //
    // See http://www.softwareishard.com/blog/har-12-spec/ for details
    har: null
}
```

### Cascading parameters
Frequently, multiple routes have common parameters. For example, all the following share the $id parameter:

* `GET /taxonomy/{id}`
* `GET /taxonomy/{id}/children`
* `GET /taxonomy/{id}/parents`

If a parameter is documented in a parent route (that is, a route higher in a parent directory), its documentation is automatically cascaded to all child routes. If a child route redefines that property, the child route definition takes precedence. Thus, in the above example, the {id} parameter only needs to be documented for the `GET /taxonomy/{id}` route.


## Model Structures
